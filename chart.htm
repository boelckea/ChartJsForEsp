<!doctype html>
<html>

<head>
    <title>Time Scale Point Data</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.13.0/moment.min.js"></script>
    <script src="Chart.js"></script>
    <script src="utils.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <style>
        canvas {
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
    </style>
</head>

<body>
<div style="width: 100%;">
    <canvas id="canvas"></canvas>
</div>
<br>
<br>
<button id="zoomIn">Zoom in</button>
<script>

    Chart.pluginService.register({
        afterUpdate: function (chart) {
            var xScale = chart.scales['x-axis-0'];
            if (xScale.options.ticks.maxTicksLimit) {
                // store the original maxTicksLimit
                xScale.options.ticks._maxTicksLimit = xScale.options.ticks.maxTicksLimit;
                // let chart.js draw the first and last label
                xScale.options.ticks.maxTicksLimit = (xScale.ticks.length % xScale.options.ticks._maxTicksLimit === 0) ? 1 : 2;

                var originalXScaleDraw = xScale.draw
                xScale.draw = function () {
                    originalXScaleDraw.apply(this, arguments);

                    var xScale = chart.scales['x-axis-0'];
                    if (xScale.options.ticks.maxTicksLimit) {
                        var helpers = Chart.helpers;

                        var tickFontColor = helpers.getValueOrDefault(xScale.options.ticks.fontColor, Chart.defaults.global.defaultFontColor);
                        var tickFontSize = helpers.getValueOrDefault(xScale.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
                        var tickFontStyle = helpers.getValueOrDefault(xScale.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
                        var tickFontFamily = helpers.getValueOrDefault(xScale.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
                        var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
                        var tl = xScale.options.gridLines.tickMarkLength;

                        var isRotated = xScale.labelRotation !== 0;
                        var yTickStart = xScale.top;
                        var yTickEnd = xScale.top + tl;
                        var chartArea = chart.chartArea;

                        // use the saved ticks
                        var maxTicks = xScale.options.ticks._maxTicksLimit - 1;
                        var ticksPerVisibleTick = xScale.ticks.length / maxTicks;

                        // chart.js uses an integral skipRatio - this causes all the fractional ticks to be accounted for between the last 2 labels
                        // we use a fractional skipRatio
                        var ticksCovered = 0;
                        helpers.each(xScale.ticks, function (label, index) {
                            if (index < ticksCovered)
                                return;

                            ticksCovered += ticksPerVisibleTick;

                            // chart.js has already drawn these 2
                            if (index === 0 || index === (xScale.ticks.length - 1))
                                return;

                            // copy of chart.js code
                            var xLineValue = this.getPixelForTick(index);
                            var xLabelValue = this.getPixelForTick(index, this.options.gridLines.offsetGridLines);

                            if (this.options.gridLines.display) {
                                this.ctx.lineWidth = this.options.gridLines.lineWidth;
                                this.ctx.strokeStyle = this.options.gridLines.color;

                                xLineValue += helpers.aliasPixel(this.ctx.lineWidth);

                                // Draw the label area
                                this.ctx.beginPath();

                                if (this.options.gridLines.drawTicks) {
                                    this.ctx.moveTo(xLineValue, yTickStart);
                                    this.ctx.lineTo(xLineValue, yTickEnd);
                                }

                                // Draw the chart area
                                if (this.options.gridLines.drawOnChartArea) {
                                    this.ctx.moveTo(xLineValue, chartArea.top);
                                    this.ctx.lineTo(xLineValue, chartArea.bottom);
                                }

                                // Need to stroke in the loop because we are potentially changing line widths & colours
                                this.ctx.stroke();
                            }

                            if (this.options.ticks.display) {
                                this.ctx.save();
                                this.ctx.translate(xLabelValue + this.options.ticks.labelOffset, (isRotated) ? this.top + 12 : this.options.position === "top" ? this.bottom - tl : this.top + tl);
                                this.ctx.rotate(helpers.toRadians(this.labelRotation) * -1);
                                this.ctx.font = tickLabelFont;
                                this.ctx.textAlign = (isRotated) ? "right" : "center";
                                this.ctx.textBaseline = (isRotated) ? "middle" : this.options.position === "top" ? "bottom" : "top";
                                this.ctx.fillText(label, 0, 0);
                                this.ctx.restore();
                            }
                        }, xScale);
                    }
                };
            }
        },
    });

    var color = Chart.helpers.color;
    var config = {
        type: 'line',
        data: {
            datasets: []
        },
        options: {
            responsive: true,
            title: {
                display: true,
                text: "Test Chart"
            },
            scales: {
                xAxes: [
                    {
                        type: "time",
                        display: true,
                        scaleLabel: {
                            display: true,
                            labelString: 'Date'
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                var dateval = values[index];
                                if (dateval !== undefined) {
                                    return new Date(values[index].value).toLocaleDateString('de-DE', { day: 'numeric', month: 'numeric', year: 'numeric', hour: 'numeric', minute: 'numeric' });
                                } else {
                                    return "";
                                }
                            },
                            autoSkip: true,
                            maxTicksLimit: 20
                        }
                    }
                ],
                yAxes: [
                    {
                        display: true,
                        beginAtZero: true,
                        scaleLabel: {
                            display: true,
                            labelString: 'value'
                        }
                    }
                ]
            }
        }
    };

    window.onload = function() {
        var colors = [window.chartColors.green, window.chartColors.red, window.chartColors.blue, window.chartColors.green, window.chartColors.grey, window.chartColors.pink];


        var xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function() {
            if (xmlhttp.readyState === XMLHttpRequest.DONE) { // XMLHttpRequest.DONE == 4
                if (xmlhttp.status === 200) {
                    // parse csv data to datasets
                    var dataSplit = xmlhttp.responseText.split("\n");
                    var datasets = [];
                    dataSplit.forEach(function(item, index) {
                        if (index === 0) {
                            // create blank datasets
                            var headerSplit = item.split(";");
                            headerSplit.forEach(function(headeritem, headerindex) {
                                if (headerindex !== 0) {
                                    var dataset = {
                                        label: headeritem,
                                        lineTension: 0,
                                        backgroundColor: color(colors[headerindex]).alpha(0.5).rgbString(),
                                        borderColor: colors[headerindex],
                                        fill: false,
                                        data: []
                                    }
                                    datasets.push(dataset);
                                }
                            });
                            return;
                        }
                        var lineSplit = item.split(";");
                        lineSplit.forEach(function(lineitem, lineindex) {
                            if (lineindex === 0) {
                                return;
                            }
                            datasets[lineindex - 1].data.push(JSON.parse('{"x": ' + lineSplit[0] + ', "y": ' + lineitem + '}'));
                        });
                    });
                    config.data.datasets = datasets;
                    var ctx = document.getElementById("canvas").getContext("2d");
                    window.firstchart = new window.Chart(ctx, config);
                } else if (xmlhttp.status === 400) {
                    alert('There was an error 400');
                } else {
                    alert('something else other than 200 was returned');
                }
            }
        };

        xmlhttp.open("GET", "data.txt", true);
        xmlhttp.send();

        //chart.config.data.datasets[1].data.push(JSON.parse('{"x": "2018-01-26T20:58:12+01:00", "y": 24}'))
        //chart.config.data.datasets[1].data.push({ x: "2018-02-26T20:58:12+01:00", y: 22 })
        //chart.config.data.datasets[1].data.push({ x: "2018-03-01T20:58:12+01:00", y: 33 })
        //chart.config.data.datasets[0].data = JSON.parse('[{ "x": "2018-01-25T20:58:12+01:00", "y": 20 }, { "x": "2018-01-26T20:58:12+01:00", "y": 10 }, { "x": "2018-01-28T20:58:12+01:00", "y": 5 }]');
        //chart.config.data.datasets[1].data = JSON.parse('[{ "x": "2018-01-25T20:58:12+01:00", "y": 10 }, { "x": "2018-01-26T20:58:12+01:00", "y": 20 }, { "x": "2018-01-28T20:58:12+01:00", "y": 15 }]');
        //chart.config.type = "bar";
        //chart.config.data.datasets[1].type = "bar";
        //chart.update();
    };

    document.getElementById('zoomIn').addEventListener('click',
        function() {
            window.firstchart.data.labels[5] = "Newly Added";
            return;
            var type = document.getElementById('type').value;
            chart.config.data.datasets[0].type = type;
            chart.update();
        });


</script>
</body>

</html>